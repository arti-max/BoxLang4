##
## Стресс-тест для многопроходного оптимизатора (-O3)
##

box putc[char c] -> void (
    asm["phs (c)"];
    asm["int $2"];
)

box get_five[] -> num24 (
    ret 5;
)

box add[num24 a, num24 b] -> num24 (
    ret a + b;
)

box multiply[num24 x, num24 y] -> num24 (
    ret x * y;
)

box _start[] -> void (
    ## --- Блок 1: Простые константы и мертвый код ---
    num24 dead_var1: 100;      ## Мертвый код. Никогда не используется. Будет удалена.
    num24 base_val: 2 * 2;     ## -> 4. Используется ниже.
    num24 another_dead: 999;   ## Еще один мертвый код.
    
    ## --- Блок 2: Цепочка зависимостей с распространением констант ---
    ## Оптимизатор должен "протащить" константу `base_val` через всю цепочку.
    num24 intermediate1: base_val + 6;      ## -> 4 + 6 -> 10.
    num24 intermediate2: intermediate1 * 3; ## -> 10 * 3 -> 30.
    num24 final_val: intermediate2;         ## -> 30. Используется в вызове функции.

    ## --- Блок 3: Вызовы функций как выражения ---
    ## Оптимизатор должен обработать вызовы функций, которые возвращают константы.
    ## В будущем здесь можно будет применить инлайнинг.
    num24 five: open get_five[];               ## -> 5.
    num24 result1: open add[five, 10];         ## -> add[5, 10] -> 15.
    
    ## Эта переменная зависит от `final_val` (30) и `result1` (15).
    num24 result2: open multiply[final_val, result1]; ## -> multiply[30, 15] -> 450.
    
    ## --- Блок 4: Финальное использование и "живой" код ---
    ## Эта переменная не является константой, так как зависит от `result2`
    ## и `final_val`, которые хоть и вычисляемы, но хранятся в переменных.
    num24 final_output: result2 - final_val; ## -> 450 - 30 -> 420.
    
    ## Этот вызов функции имеет сайд-эффект и не должен быть удален.
    ## Все переменные, ведущие к `final_output`, также являются "живым" кодом.
    open putc[(char)final_output];
)

